---
title: "Food chian length and food web motives"
output: html_notebook
---

In this notebook, we generate acyclic food webs with three definitions of
species' trophic levels.
We use PPM to generate food webs, and then we run dynamics simulations
to see relaized food chain length and food web motives.


```{r Generating food webs}
library(igraph)
assign_extra_prey = function(A, TL, s_j,  T, ki, i){
  # Assign extra preyspecies to species i
  #------------------------------------
  # A: adj matrix 
  # TL trophic level vector
  # s_j index of specie i's first prey
  # T controls whether species can eat different TL species or not
  # ki is the (maximum) number of etra prey species
  # i predator's index
  #------------------------------------
  # we need to calculate prob of choosing additional prey
  P=rep(0, i-1)
  TL_first=TL[s_j] # trophic level of first chosen prey species
  for (j in 1:(i-1)){
    P[j]=exp(-abs(TL_first-TL[j])/T)
  }
  #P[s_j]=0 # if we set so, the number of links inflates
  rand= runif(ki, 0, 1) # we need ki random value from 0 to 1
  # note that we should not choose the first prey any more
  for(j in 1:ki){
    P=P/sum(P) #normalization
    n=0.0
    for(k in 1:(i-1)){
      if (rand[j]<n+P[k]){
        # species k is an extra prey species
        A[k, i]=1
        #P[k] = 0 # if we set so, the number of links inflates
        break
      }
      else{
        n=n+P[k]
      }
    }
    if(sum(P)<=0){
      # ki might be larger than i-1
      break
    }
  } # additional prey species loop
  return (A)
}

PPM= function(N, B, L, TL_def=0, T=1){
  
  # Implement PPM, but we have two modifications.
  #1. We do not allow cannibalism
  #2. We can alter the definition of species' tropic levels
  #-------------------------------------------------------------------------------------
  #N is the number of species
  #B is the number of prey species
  #L is the expected number of links
  #TL_def: definition of trophic level. -1: shortest path from a basal species, 
  #       0: mean trophic level of prey+1, 1: lonest path from a basal species
  # In the origical model, trophic level (TL) is given by the mean trophic level of preys
  #However, we could define TL using the shortest or longest path
  
  #T controls whether species can eat different TL species or not
  #------------------------------------------------------------------------------------
  if (B>=N){
    print("Error: the number of basal species should be smaller than the total number of species")
    return (1)
  }
  else if(B<=0){
    print("We need at least one basal species")
    return (1)
  }
  else{
    # Step 1: assign Trophic level of basal species.
    TL=c(rep(1, B), rep(-1, N-B))  # TL vector. For non basal species, we use -1 at first
    A=matrix(0, N, N) # adj matrix
    
    # Step 2 assign non-basal species
    for (i in (B+1):N){
      s_j=sample.int(i-1, 1) # first chosen prey species
      # assign certain number of additional prey species
      # the number of additional prey follows the niche model
      # see https://www.nature.com/articles/35004572
      ni=i-1 # number of specie 
      beta=(N^2 - B^2)/(2*L)-1
      xi= rbeta(1, shape1 = 1, shape2 = beta)
      ki=round(ni*xi) #this is the number of extra prey species
      A[s_j, i]=1 # species i eats species s_j
      if (ki>=1){
        # Function below update A and choose extra prey species
        A=assign_extra_prey(A, TL, s_j, T, ki, i)
      }
      
      # define TL of species i
      if (TL_def==0){
        # we define FCL by mean prey's tropic level
        # here we assume unbiased predation
        TL[i] = 1+(TL[1:(i-1)]%*%A[1:(i-1), i])/sum(A[1:(i-1), i])
      }
      else if (TL_def==-1){
        # TL of species i is defined by 1+the shortest path from a basal species
        graph=graph_from_adjacency_matrix(A,mode='directed')
        TL[i] = 1+min(distances(graph,to = i, mode='out')[1:B]) # we only care distances from basal species to species i
      }
      else if (TL_def==1){
        #TL of species i is defined by 1+the longest path from a basal species
        # Because igraph does not have an algorithm for the longest path
        # we will use the shortest path with negative weights
        graph=graph_from_adjacency_matrix(-A,mode='directed', weight=TRUE)
        TL[i] =1- min(distances(graph,to = i, mode='out')[1:B]) # we only care distances from basal species to species i
      }
      else{
        print("Error: TL_def=-1, 0, or 1. Pease check the source code")
        return (1)
      }
      
    }# end for loop for each non-basal species
  }# end generating food web
  return (list(A, TL))
}

CheckIsolation=function(A){
  N=nrow(A)
  for(i in 1:N){
     if(sum(A[i,], A[, i])<=0){
       # species i does not predate other species or is not eaten by other species
       return(0) 
     }
  }
  return(1)
}

Main=function(N, B, L, rep, TL_def=0, T=1){
  # Main function to generate multiple food webs
  # N number of species (int)
  # B number of basal species in a food web. This should be a list
  # L expected number of edges in a food web. 
  # We recommend use L that gives connectance =0.11 
  # following (https://pnas.org/doi/full/10.1073/pnas.192407699)
  # rep number of replicates per value of B
  # TL_def: definition of trophic level: -1 , 0 or 1. See PPM function above
  # T parameter to control omnivore. See PPm function above
  
  path=paste0("./Species", N)
  dir.create(path, recursive = FALSE)
  #setwd(path)
  for(i in 1:length(B)){
    b=B[i]
    path1=paste0(path, "./basal", b)
    dir.create(path1, recursive = FALSE)
    count=1
    #setwd(path1)
    while(count<=rep){
      # generate a food web
      ans=PPM(N, b, L, TL_def, T=1)
      A=ans[1][[1]]
      TL=ans[2][[1]]
      
      # check whether the food web has no isolated species or not
      if (CheckIsolation(A)==1){
        # passed
        write.table(A, paste0(path1, "/TLDef_", TL_def, "FoodWeb_", count, ".csv"),
                    sep =",", row.names = FALSE)
        write.table(TL, paste0(path1, "/TLDef_", TL_def, "TrophicLevel_", count, ".csv"),
                    sep=",", row.names=FALSE)
        count=count+1
      }
    }
    #setwd("../")
  }
  #setwd("../")
}

#------Run below----
print("Mean prey TL")
Main(32, c(4), 113,30, 0)
print("Shortest path")
Main(32, c(4), 113,30, -1)
print("Longest path")
Main(32, c(4), 113,30, 1)
```
Note that above generated food webs are only those when all species coexist.
In the below codes, we run ecological dynamics, where some of species go extinct.
Then, we calculate realized food chain length and food web motives


```{r Dynamics}
library(GillespieSSA)
colonization_extinction_single=function(A_f, B){
  #-----------------------------------
  # Return symbolic representations of colonization and extinction rates used in Gli. alg
  # A_f: adjacency matrix of the food web
  #  parm should contain B: number of basal species
  # --------------- IMPORTANT -------------------
  # It seems that GillespieSSA stops simulations when all x = 0. 
  # For this reason,  we assume P=1 is absent while P=2 is present, 
  # although we will use P=0 as absence and P=1 as presence in the manuscript
  #-----------------------------------
  # colonization and extinction rate in single patch
  N=ncol(A_f) # number of species
  F=rep(0, N) # colonization
  G=rep(0, N) # extinction
  P=paste0("P", seq(from = 1, to = N, by = 1)) # presence/absence of species in the patch
  sum_basal=paste(P[1], -1) # symbolic representation of sum of basal species
  if(B>1){
    for (i in 2:B){
      sum_basal = paste(sum_basal, '+', P[i], -1)
    }
  }
  # calculate number of prey and predators per species , respectively
  rho=rep(0, N) # number of prey
  q=rep(0, N) # number of predator
  for (i in 1:N){
    for (k in 1:N){
      # Count number of prey and predators
      if (A_f[k,i]>0){
        if(rho[i]==0){
          rho[i] = paste0(P[k], -1)
        }
        else{
          rho[i] = paste(rho[i], '+', P[k], -1) #If P=2=> add one (see above IMPORTANT)
        }
      }
      if (A_f[i, k]>0){
        if(q[i]==0){
          q[i] = paste0(P[k], -1)
        }
        else{
          q[i] = paste(q[i], '+', P[k], -1)
        }
      }
    }
    
   # generate species colonization rate
    if (i <= B){
      # species i is a basal species
      F[i] = paste0("(2-(", P[i], "))*a_",i, "*exp(-(", sum_basal, ")/R)")
    }
    else{
      # species i is a non-basal species
      F[i] = paste0("(2-(", P[i],"))*b_", i, "*(", rho[i], ")^(h1)/((", rho[i], ")^(h1)+K^(h1))")
    }
    # generate extinction rate
    G[i] =paste0("(", P[i], "-1)*(c_", i, "*(", q[i], ")^(h2)/((", q[i], ")^(h2)+L^(h2)) + d_",i, "*M^(h3)/(M^(h3)+(", rho[i], ")^(h3)) +e_",i, ")")
  }
  return(c(F, G))
}
Presence=function(state, A_f, B){
  # remove species that do not have any prey species
  # state: presence of species 
  # A_f adjacency matrix of food web
  # B the number of basal species
  N=length(state)
  for (i in (B+1):N){
    # we do not care about basal species i=1, ..., B
    if (sum(A_f[, i]*state )< 1 ){
      # species i has no prey species and should go extinct
      state[i]=0
    }
  }
  return (state)
  
}
single_patch = function (A_f, parm, TL_def=0, replicate=100, tf=1000, SimName='single patch model'){
 #------------- Analyze single patch model given the number of data----------
  # A_f adjacency matrix of food web
  # parm parameters used to run simulations
  # parms include a(colonization of basal), b (colonization of non-basal),c (max extinction rate by predation),d (max extinction rate by lack of prey), R (resource availability in patch), 
  # h1, h2, h3, K, L, M,
  # TL_def: definition of TL
  # replicate number of replicate we run
  # tf time final
  #--------------define some  values and vectors------------------------
  N= ncol(A_f) # number of species in the system
  B=sum(colSums(A_f)==0)  # number of basal species is the number of cols that sum is 0
  init=rep(1, N) # initially no species exist. REMEBER, we use P=1 as absence and P=2 as presence in the codes
  names(init)=paste0("P", seq(from = 1, to = N, by = 1)) # add names P_i (dropping j=1 from P_ij)
  #We generate colonization and extinction functions from A_f
  a=colonization_extinction_single(A_f, B) # Define propensity functions 
  nu = matrix(c(diag(N), -diag(N)), nrow=N) # Define state-change matrix
  final_presence=c()
  # Debugged until above
  for(rep in 1:replicate){
    #------------ Single run of dynamics --------------
    # Currently simulation ends quickly... why?
    out <- ssa(x0 = init,a = a,nu = nu,parms = parm ,tf = tf,
    method = ssa.d(),simName = SimName,verbose = FALSE,consoleInterval = 1)
    # here we use slow direct method, but we can change the method once we confirm that approx methods are fine
    # Then we want to calculate FCL
    if (out$data[nrow(out$data),1] >tf){
      # we now use 1 as presence and 0 as absence
      state_f=out$data[nrow(out$data)-2, 2:ncol(out$data)]-1# time and presence/absence vector at the end
    }
    else{
      state_f=out$data[nrow(out$data), 2:ncol(out$data)]-1
    }
    #print(state_f)
    final_presence=rbind(final_presence, Presence(state_f, A_f, B))
  }
  colnames(final_presence)=paste0("Sp", seq(from = 1, to = N, by = 1))
  return (data.frame(Replicate=seq(1, replicate, 1), final_presence))
}

ParmGeneraotr = function(N, B, resource, disturbunce, eco_size){
  #----------------------------------------
  #Generate parameters needed to run simulations
  # N: number of total species in a community
  # B: number of basal species
  # resource: resource availability that determines the number of coexisting basal species
  # disturbances: strength of disturbances that drive species extinction
  # eco_size: eco-system sizes which affect  the max colonization rates
  #----------------------------------------
  parm=c(rep(eco_size, N), # a 
         rep(eco_size, N), # b
         rep(0.3, N), # c
         rep(0, B), # d_basal
         rep(10, N-B), #d_non-basal
         rep(disturbunce,N), # e
         resource, # R
         1, 2, 0.05, 1,1,1) # K-M, h1, h2, h3
  A=c()
  B=c()
  C=c()
  D=c()
  E=c()
  for (i in 1:N){
    A=c(A, paste0("a_", i))
    B=c(B, paste0("b_", i))
    C=c(C, paste0("c_", i))
    D=c(D, paste0("d_", i))
    E=c(E, paste0("e_", i))
  }
  name_parm=c(A, B, C, D, E)
  name_parm=c(name_parm, "R", "K", "L", "M", "h1", "h2", "h3")
  names(parm)=name_parm
  return(parm)
}

Main=function(num_network, TL_def, N=32, Basal=4){
  #--------------------------------
  # Main function to run simulations and save FCL at the end
  # N (int): number of species in a community
  # B (list): list of the number of basal species
  # num_network (int): number of food webs per B
  #--------------------------------
  # design resource parm set. This is based on N and B
  E=c(0.1, 0.5, 0.9)
  R=c(1, 2, 4, 8)
  Eco=c(0.5, 1, 2) 
  setwd(paste0("./Species", N, "/basal",Basal))
  for (j in 1:num_network){
    # Read adjacency matrix of food web
    A_f=read.csv(file = paste0("TLDef_", TL_def, "FoodWeb_", j, ".csv"))
    ans=c()
    for (k in 1:length(R)){
      resource = R[k]
      for (l in 1:length(E)){
          disturbance=E[l]
          for(m in 1:length(Eco)){
            eco_size=Eco[m]
             #Generate parm
              parm = ParmGeneraotr(N, Basal, resource, disturbance, eco_size)
              # Run simulation
              fcl=single_patch(A_f, parm, TL_def, replicate=100)
              fcl=cbind(rep(resource,nrow(fcl)), rep(disturbance,nrow(fcl)),rep(eco_size, nrow(fcl)), fcl)
              names(fcl)=c("resource", "disturbance", "ecosystem", "replicate",
                           paste0("Sp", seq(from = 1, to = N, by = 1)))
              ans=rbind(ans, fcl)
          }
      }
    }
    write.table(ans, paste0("TLDef_",TL_def , "Presence_FoodWeb_", j,".csv"), sep=",", row.names = FALSE)
  }
  setwd("../../")
}
print("Mean Prey TL")
Main(30, 0)
print("Shortest path")
Main(30, -1)
print("Longest path")
Main(30, 1)
```


Now we analyze the relationship between FCL and food web motives in simulation data
```{r Analysis}
library(ggplot2)
library(igraph)
library(tidyverse)
Reconstract_FW =function(presence_array, full_FW, TL_def){
  #--------------------------------------------
  # This function generate realized food web and calculate FWL and food web motives
  # presence_array: array of presence of each species. 1: presence, 0: absence
  # full_FW NxN food web. The realized food web is a sub-matrix of this matrix
  # TL_def: 0 Trophic level is given by the mean prey trophic levels
  #     -1: TL is defined by the shortest-path length
  #      1: TL is defined by the longest-path length  
  #--------------------------------------------
  n= sum (presence_array) # number of existing species
  if(n==0){
    # no species exist
    FCL=-1
    motif=matrix(rep(NaN, 16), ncol=16)
    data=data.frame(FCL, richness=0, motif)
    colnames(data) = c('FCL', 'richness', "empty","monoA.single","bi.single",
                    "exploitative","apparent","chain","d4","d3","omnivory",
                    "s3","d8","d2","d1","d5","d7","d6")
   data=subset(data, select = c(FCL, richness, chain, omnivory, apparent, exploitative) ) # ignore others as FW is acyclic 
    # change order
    data=data %>% select(order(colnames(data)))
    data=dplyr::select(data, FCL,chain,omnivory, apparent, exploitative, everything())
    return(data)
  }
  adj=matrix(0, n, n)
  indexes=c() # indexes of present species
  for (i in 1:length(presence_array)){
    if(presence_array[i]==1){
      indexes=c(indexes, i)
    }
  }
  for(i in 1:n){
    for (j in  1:n){
      adj[i, j] = full_FW[indexes[i], indexes[j]]
    }
  }
  # calculate FCL
 
  TL=rep(0, n) # trophic levels
  B=c() # array of basal species
  for (i in 1:n){
    if(sum(adj[, i])==0)
    {
      # species i is a basal species
      TL[i]=1
      B=c(B, i)
    }
    else{
      # calculate TL
      if (TL_def==0){
        # TL=1 + mean of prey TL
        
        TL[i] = 1+(TL[1:(i-1)]%*%adj[1:(i-1), i])/sum(adj[1:(i-1), i])
      }else if(TL_def==-1){
        #TL= 1+ shortest-path length from basal species
         graph=graph_from_adjacency_matrix(adj,mode='directed') # graph used in igraph
         
         TL[i] = 1+min(distances(graph,to = i, mode='out')[B]) 
      } else{
        #TL = 1+ longest-path length
        graph=graph_from_adjacency_matrix(-adj,mode='directed', weight=TRUE)
        TL[i] =1- min(distances(graph,to = i, mode='out')[B]) # we only care distances from basal species to
      }
    }
  }
  FCL=-1+max(TL)
  
  # calculate fractions of motives
  graph=graph_from_adjacency_matrix(adj,mode='directed')
  motif=matrix(triad_census(graph), nrow=1)
  #motif=motif/sum(motif) # convert into fractions
 
  data=data.frame(FCL, richness=n, motif)
  colnames(data) = c('FCL', 'richness', "empty","monoA.single","bi.single",
                    "exploitative","apparent","chain","d4","d3","omnivory",
                    "s3","d8","d2","d1","d5","d7","d6")
  data=subset(data, select = c(FCL, richness, chain, omnivory, apparent, exploitative) ) # ignore others as FW is acyclic 
  data[3:ncol(data)]=data[3:ncol(data)]/(sum(data[3:ncol(data)])) # fractions of motives
  # change order
  data=data %>% select(order(colnames(data)))
  data=dplyr::select(data, FCL,richness, chain,omnivory, apparent, exploitative, everything())
  return(data)
}
Main= function(TL_def, num_FW=30){
  #generate summary csv file to analyze simulation data
  D=c()
  for (n in 1:num_FW){
    data=read.csv(paste0('./Species32/basal4/TLDef_',TL_def,'Presence_FoodWeb_',n,'.csv'))
    presence_array=data[, 5:ncol(data)]
    full_FW=read.csv(paste0('./Species32/basal4/TLDef_',TL_def,'FoodWeb_',n,'.csv'))
    ans=c()
    for (i in 1:nrow(data)){
      ans=rbind(ans, Reconstract_FW(presence_array[i, ], full_FW, TL_def))
    }
    D=rbind(D, cbind(FW=n, data[, 1:4], ans))
  }
  return(D)
}
data_long=Main(1)
write.csv(data_long, './FCL_long_simulations_summary.csv', row.names = FALSE)
data_mean=Main(0)
write.csv(data_mean, './FCL_mean_simulations_summary.csv', row.names = FALSE)
data_short=Main(-1)
write.csv(data_short, './FCL_short_simulations_summary.csv', row.names = FALSE)
```

Below we plot and analyze data
```{r FCL analysis}
library(ggcorrplot)
Plot_corr=function(data, FCL_name, fname, legend=FALSE){
  df=subset(data, select = c(FCL, richness, chain, omnivory, apparent, exploitative, resource, disturbance, ecosystem) )
  colnames(df) = c(FCL_name, 'Richness', 
                 'Chain', 'Omnivory', 'Apparent comp', 'Exploitative comp', 
                 'Resource', 'Disturbance', 'Ecosystem')
  corr=cor(df, use = "pairwise.complete.obs", method='spearman') # pearson and spearman show similar results
  print(corr)
  p.mat <- cor_pmat(df, use = "pairwise.complete.obs",  method='pearson') # p values
  ggcorrplot(corr, type = "lower", p.mat = p.mat, tl.cex=20, show.legend=legend)
  ggsave(fname)
}

Plot_corr(data_long, 'FCL long', 'Simulated_FCL_long_correlation.pdf')
Plot_corr(data_mean, 'FCL mean',  'Simulated_FCL_mean_correlation.pdf')
Plot_corr(data_short, 'FCL short', 'Simulated_FCL_short_correlation.pdf', legend=TRUE)

library(car)
# Next we perform statistical analysis.
# Each model contains variables whose correlation with FCL >0.2 or < -0.2
df_long=subset(data_long, select = c(FCL, richness, chain, omnivory, apparent, exploitative, resource, disturbance) )
df_long=replace(df_long, is.na(df_long), 0) # fill na with zero before scalling
df_long[, 2:ncol(df_long)]=scale(df_long[, 2:ncol(df_long)])
summary(lm(formula = FCL ~ richness + chain + exploitative+omnivory*disturbance, data = df_long))
vif(lm(formula = FCL ~ richness + chain + exploitative+omnivory*disturbance, data = df_long))

df_mean=subset(data_mean, select = c(FCL, richness, chain, omnivory, apparent, exploitative, resource, disturbance) )
df_mean=replace(df_mean, is.na(df_mean), 0) # fill na with zero before scalling
df_mean[, 2:ncol(df_mean)]=scale(df_mean[, 2:ncol(df_mean)])
summary(lm(formula = FCL ~ richness + chain + exploitative+omnivory*disturbance, data = df_mean))
vif(lm(formula = FCL ~ richness + chain + exploitative+omnivory*disturbance, data = df_mean))


df_short=subset(data_short, select = c(FCL, richness, chain, omnivory, apparent, exploitative, resource, disturbance) )
df_short=replace(df_short, is.na(df_short), 0) # fill na with zero before scalling
df_short[, 2:ncol(df_short)]=scale(df_long[, 2:ncol(df_short)])
summary(lm(formula = FCL ~ richness + chain + exploitative+omnivory*disturbance, data = df_short))
vif(lm(formula = FCL ~ richness + chain + exploitative+omnivory*disturbance, data = df_short))
```

Below, we check the distributions of FCL and species richness in the simulation data
```{r}
print('FCL long')
ggplot(data_long, aes(x=richness)) + geom_bar()+xlab('Richness')+ylab('Count')+ theme(text = element_text(size = 20))   
ggsave("Simulation_FCL_long_richness.pdf")
ggplot(data_long, aes(x=FCL)) + geom_bar()+xlab('FCL long')+ylab('Count')+ theme(text = element_text(size = 20))   
ggsave("Simulation_FCL_long_FCL.pdf")

print('FCL mean')
ggplot(data_mean, aes(x=richness)) + geom_bar()+xlab('Richness')+ylab('Count')+ theme(text = element_text(size = 20))   
ggsave("Simulation_FCL_mean_richness.pdf")
ggplot(data_mean, aes(x=FCL)) + geom_histogram()+xlab('FCL mean')+ylab('Count')+ theme(text = element_text(size = 20))   
ggsave("Simulation_FCL_mean_FCL.pdf")

print('FCL short')
ggplot(data_short, aes(x=richness)) + geom_bar()+xlab('Richness')+ylab('Count')+ theme(text = element_text(size = 20))   
ggsave("Simulation_FCL_short_richness.pdf")
ggplot(data_short, aes(x=FCL)) + geom_bar()+xlab('FCL short')+ylab('Count')+ theme(text = element_text(size = 20))   
ggsave("Simulation_FCL_short_FCL.pdf")

```

```{r WHY FCL short is incocistent between simulations and empirical data}
g1=ggplot(data_short, aes(x=as.factor(disturbance), y=FCL)) + geom_violin()
g1=g1+xlab('Disturbance')+ylab('FCL short')+ theme(text = element_text(size = 20)) 
ggsave('FCL_short_disturbance.pdf')
g2=ggplot(data_short, aes(x=as.factor(disturbance), y=richness)) + geom_violin()
g2=g2+xlab('Disturbance')+ylab('Richness')+ theme(text = element_text(size = 20)) 
ggsave('FCL_short_richness.pdf')

# what happens when we remove data FCL<1
summary(lm(formula = FCL ~ richness + chain + exploitative+omnivory, data = df_short[df_short$FCL>1, ]))

```
Next, as we show in the empirical data, we plot the FCL aginst motives as well as against resource, disturbances, and ecosystem sizes
```{r Plot FCL against motives}
library(patchwork)
# against motives
# FCL long
df_long=read.csv("FCL_long_simulations_summary.csv")

p1=ggplot(df_long, aes(x=chain, y=FCL, size=4, alpha=0.1))+geom_point(color='#a6cee3')+ylab('FCL long')+xlab("Chain")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=11, label=paste0('corr.=', round(cor.test(df_long$FCL, df_long$chain, method='spearman')$estimate, 3)), size=5)

p2=ggplot(df_long, aes(x=omnivory, y=FCL, size=4, alpha=0.1))+geom_point(color='#1f78b4')+ylab('FCL long')+xlab("Omnivory")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=11, label=paste0('corr.=', round(cor.test(df_long$FCL, df_long$omnivory, method='spearman')$estimate, 3)), size=5)

p3=ggplot(df_long, aes(x=apparent, y=FCL, size=4, alpha=0.1))+geom_point(color='#b2df8a')+ylab('FCL long')+xlab("Apparent")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=11, label=paste0('corr.=', round(cor.test(df_long$FCL, df_long$apparent, method='spearman')$estimate, 3)), size=5)

p4=ggplot(df_long, aes(x=exploitative, y=FCL, size=4, alpha=0.1))+geom_point(color='#33a02c')+ylab('FCL long')+xlab("Exploitative")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=11, label=paste0('corr.=', round(cor.test(df_long$FCL, df_long$exploitative, method='spearman')$estimate, 3)), size=5)

df_mean=read.csv("FCL_mean_simulations_summary.csv")

p5=ggplot(df_mean, aes(x=chain, y=FCL, size=4, alpha=0.1))+geom_point(color='#a6cee3')+ylab('FCL mean')+xlab("Chain")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_mean$FCL, df_mean$chain, method='spearman')$estimate, 3)), size=5)

p6=ggplot(df_mean, aes(x=omnivory, y=FCL, size=4, alpha=0.1))+geom_point(color='#1f78b4')+ylab('FCL mean')+xlab("Omnivory")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_mean$FCL, df_mean$omnivory, method='spearman')$estimate, 3)), size=5)

p7=ggplot(df_mean, aes(x=apparent, y=FCL, size=4, alpha=0.1))+geom_point(color='#b2df8a')+ylab('FCL mean')+xlab("Apparent")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_mean$FCL, df_mean$apparent, method='spearman')$estimate, 3)), size=5)

p8=ggplot(df_mean, aes(x=exploitative, y=FCL, size=4, alpha=0.1))+geom_point(color='#33a02c')+ylab('FCL mean')+xlab("Exploitative")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_mean$FCL, df_mean$exploitative, method='spearman')$estimate, 3)), size=5)

df_short=read.csv("FCL_short_simulations_summary.csv")

p9=ggplot(df_short, aes(x=chain, y=FCL, size=4, alpha=0.1))+geom_point(color='#a6cee3')+ylab('FCL short')+xlab("Chain")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_short$FCL, df_short$chain, method='spearman')$estimate, 3)), size=5)

p10=ggplot(df_short, aes(x=omnivory, y=FCL, size=4, alpha=0.1))+geom_point(color='#1f78b4')+ylab('FCL short')+xlab("Omnivory")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_short$FCL, df_short$omnivory, method='spearman')$estimate, 3)), size=5)

p11=ggplot(df_short, aes(x=apparent, y=FCL, size=4, alpha=0.1))+geom_point(color='#b2df8a')+ylab('FCL short')+xlab("Apparent")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_short$FCL, df_short$apparent, method='spearman')$estimate, 3)), size=5)

p12=ggplot(df_short, aes(x=exploitative, y=FCL, size=4, alpha=0.1))+geom_point(color='#33a02c')+ylab('FCL short')+xlab("Exploitative")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_short$FCL, df_short$exploitative, method='spearman')$estimate, 3)), size=5)

p1+p5+p9+p2+p6+p10+p3+p7+p11+p4+p8+p12+plot_layout(nrow = 4,)+plot_annotation(tag_levels = "A")&theme(plot.tag = element_text(size = 32))
ggsave('FCL_simulation_motives.png', width=12, height=16)
```

```{r Plot FCL against environments}
df_long=read.csv("FCL_long_simulations_summary.csv")

p1=ggplot(df_long, aes(x=resource, y=FCL, size=3, alpha=0.005))+geom_point(color='#7570b3')+ylab('FCL long')+xlab("Resource")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(1,8))+annotate(geom="text", x=3, y=11, label=paste0('corr.=', round(cor.test(df_long$FCL, df_long$resource, method='spearman')$estimate, 3)), size=5)

p2=ggplot(df_long, aes(x=disturbance, y=FCL, size=4, alpha=0.005))+geom_point(color='#d95f02')+ylab('FCL long')+xlab("Disturbance")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=11, label=paste0('corr.=', round(cor.test(df_long$FCL, df_long$disturbance, method='spearman')$estimate, 3)), size=5)

p3=ggplot(df_long, aes(x=ecosystem, y=FCL, size=4, alpha=0.005))+geom_point(color='#1b9e77')+ylab('FCL long')+xlab("Ecosystem")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0.5,2.0))+annotate(geom="text", x=0.75, y=11, label=paste0('corr.=', round(cor.test(df_long$FCL, df_long$ecosystem, method='spearman')$estimate, 3)), size=5)


df_mean=read.csv("FCL_mean_simulations_summary.csv")

p4=ggplot(df_mean, aes(x=resource, y=FCL, size=3, alpha=0.005))+geom_point(color='#7570b3')+ylab('FCL mean')+xlab("Resource")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(1,8))+annotate(geom="text", x=3, y=9, label=paste0('corr.=', round(cor.test(df_mean$FCL, df_mean$resource, method='spearman')$estimate, 3)), size=5)

p5=ggplot(df_mean, aes(x=disturbance, y=FCL, size=4, alpha=0.005))+geom_point(color='#d95f02')+ylab('FCL mean')+xlab("Disturbance")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_mean$FCL, df_mean$disturbance, method='spearman')$estimate, 3)), size=5)

p6=ggplot(df_mean, aes(x=ecosystem, y=FCL, size=4, alpha=0.005))+geom_point(color='#1b9e77')+ylab('FCL mean')+xlab("Ecosystem")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0.5,2.0))+annotate(geom="text", x=0.75, y=9, label=paste0('corr.=', round(cor.test(df_mean$FCL, df_mean$ecosystem, method='spearman')$estimate, 3)), size=5)

df_short=read.csv("FCL_short_simulations_summary.csv")

p7=ggplot(df_short, aes(x=resource, y=FCL, size=3, alpha=0.005))+geom_point(color='#7570b3')+ylab('FCL short')+xlab("Resource")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(1,8))+annotate(geom="text", x=3, y=9, label=paste0('corr.=', round(cor.test(df_short$FCL, df_short$resource, method='spearman')$estimate, 3)), size=5)

p8=ggplot(df_short, aes(x=disturbance, y=FCL, size=4, alpha=0.005))+geom_point(color='#d95f02')+ylab('FCL short')+xlab("Disturbance")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0,1.0))+annotate(geom="text", x=0.4, y=9, label=paste0('corr.=', round(cor.test(df_short$FCL, df_short$disturbance, method='spearman')$estimate, 3)), size=5)

p9=ggplot(df_short, aes(x=ecosystem, y=FCL, size=4, alpha=0.005))+geom_point(color='#1b9e77')+ylab('FCL short')+xlab("Ecosystem")+theme(
axis.text.x = element_text(size=14),
  axis.title.x = element_text(size=20),
   axis.text.y = element_text(size=14),
  axis.title.y = element_text(size=20),
  legend.position="none"
  )+xlim(c(0.5,2.0))+annotate(geom="text", x=0.75, y=9, label=paste0('corr.=', round(cor.test(df_short$FCL, df_short$ecosystem, method='spearman')$estimate, 3)), size=5)

p1+p4+p7+p2+p5+p8+p3+p6+p9+plot_layout(nrow = 4,)+plot_annotation(tag_levels = "A")&theme(plot.tag = element_text(size = 32))
ggsave('FCL_simulation_environemnt.png', width=12, height=9)
```

We can see that FCL correlate with disturbance and ecosystem sizes, respectively, in any definition.